#!/usr/bin/env ruby

# @package MiGA
# @license Artistic-2.0

$:.push File.expand_path("../lib", File.dirname(__FILE__))

require "optparse"
require "miga"

##=> Global variables <=

$task_desc = {
  # Projects
  create_project: "Creates an empty MiGA project.",
  project_info: "Displays information about a MiGA project.",
  # Datasets
  create_dataset: "Creates an empty dataset in a pre-existing MiGA project.",
  download_dataset: "Creates an empty dataset in a pre-existing MiGA project.",
  unlink_dataset: "Removes a dataset from an MiGA project.",
  find_datasets: "Finds unregistered datasets based on result files.",
  import_datasets: "Link datasets (including results) from one project to "+
    "another.",
  list_datasets: "Lists all registered datasets in an MiGA project.",
  # Results
  add_result: "Registers a result.",
  result_stats: "Extracts statistics for the given result.",
  list_files: "Lists all registered files from the results of a dataset or a "+
    "project.",
  # System
  daemon: "Controls the daemon of a MiGA project.",
  date: "Returns the current date in standard MiGA format.",
  # Taxonomy
  add_taxonomy: "Registers taxonomic information for datasets.",
  index_taxonomy: "Creates a taxonomy-indexed list of the datasets.",
  tax_distributions: "Estimates distributions of distance by taxonomy.",
}

##=> Functions <=

# OptParse banner
def opt_banner(opt)
  opt.banner = <<BAN
#{$task_desc[$task]}

Usage: #{$0} #{$task} [options]
BAN
  opt.separator ""
end

# OptParse flags that determine the object to load
def opt_object(opt, o, what=[:project, :dataset])
  opt.on("-P", "--project PATH", "(Mandatory) Path to the project."
    ){ |v| o[:project]=v } if what.include? :project
  opt.on("-D", "--dataset PATH", "(Mandatory) Name of the dataset."
    ){ |v| o[:dataset]=v } if what.include? :dataset
  opt.on("-D", "--dataset PATH", "Name of the dataset."
    ){ |v| o[:dataset]=v } if what.include? :dataset_opt
  opt.on("-t", "--type STRING",
    "Type of dataset. Recognized types include:",
    *MiGA::Dataset.KNOWN_TYPES.map{ |k,v| "~ #{k}: #{v[:description]}" }
    ){ |v| o[:type]=v.to_sym } if what.include? :dataset_type
  opt.on("-t", "--type STRING",
    "Type of dataset. Recognized types include:", 
    *MiGA::Project.KNOWN_TYPES.map{ |k,v| "~ #{k}: #{v[:description]}"}
    ){ |v| o[:type]=v.to_sym } if what.include? :project_type
  opt.on("-r", "--result STRING",
    "(Mandatory) Name of the result to add.",
    "Recognized names for dataset-specific results include:",
    *MiGA::Dataset.RESULT_DIRS.keys.map{|n| " ~ #{n}"},
    "Recognized names for project-wide results include:",
    *MiGA::Project.RESULT_DIRS.keys.map{|n| " ~ #{n}"}
    ){ |v| o[:name]=v.downcase.to_sym } if what.include? :result
end

# OptParse flags common to all actions.
def opt_common(opt, o)
  opt.on("-v", "--verbose",
    "Print additional information to STDERR."){ o[:q]=false }
  opt.on("-d", "--debug INT", "Print debugging information to STDERR.") do |v|
    v.to_i>1 ? MiGA::MiGA.DEBUG_TRACE_ON : MiGA::MiGA.DEBUG_ON
  end
  opt.on("-h", "--help", "Display this screen.") do
    puts opt
    exit
  end
  opt.separator ""
end

# OptParse flags to filter lists of datasets.
def opt_filter_datasets(opt, o, what=[:ref, :multi, :taxonomy])
  opt.on("--[no-]ref",
    "If set, uses only reference (or only non-reference) datasets."
    ){ |v| o[:ref]=v } if what.include? :ref
  opt.on("--[no-]multi",
    "If set, uses only multi-species (or only single-species) datasets."
    ){ |v| o[:multi]=v } if what.include? :multi
  opt.on("-t", "--taxonomy RANK:TAXON", "Filter by taxonomy."
    ){ |v| o[:taxonomy]=MiGA::Taxonomy.new v } if what.include? :taxonomy
end

def opt_require(o, req={project:"-P", dataset:"-D"})
  req.each do |k,v|
    raise "#{v} is mandatory: please provide #{k}." if o[k].nil?
  end
end

# Filters datasets by keys set in +opt_filter_datasets+.
def filter_datasets!(ds, o)
  ds.select!{|d| d.is_ref? == o[:ref] } unless o[:ref].nil?
  ds.select! do |d|
    o[:multi] ? d.is_multi? : d.is_nonmulti?
  end unless o[:multi].nil?
  ds.select! do |d|
    (not d.metadata[:tax].nil?) and d.metadata[:tax].is_in?(o[:taxonomy])
  end unless o[:taxonomy].nil?
  ds
end

##=> Main <=

execs = $task_desc.keys.map{ |k| k.to_s }

case ARGV[0]
when "-v", "--version"
  puts MiGA::MiGA.VERSION
when "-V", "--long-version"
  puts MiGA::MiGA.LONG_VERSION
when "-C", "--citation"
  puts MiGA::MiGA.CITATION
when *execs
  $task = ARGV.shift.to_sym
  ARGV << "-h" if ARGV.empty? and not [:date].include? $task
  begin
    load File.expand_path("../actions/#{$task}.rb", File.dirname(__FILE__))
  rescue => err
    $stderr.puts "Exception: #{err}\n\n"
    err.backtrace.each { |l| $stderr.puts l + "\n" }
    err
  end
else
  print <<HELP

Microbial Genomes Atlas.

Usage: #{$0} {action} [options]

#{ MiGA::MiGA.tabulate([:action, :description], $task_desc.to_a).join("\n")}

generic options:
    -h, --help          Display this screen.
    -v, --version       Show MiGA version.
    -V, --long-version  Show complete MiGA version.
    -C, --citation      How to cite MiGA.

HELP
end

