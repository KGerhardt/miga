#!/usr/bin/env ruby

# @package MiGA
# @license Artistic-2.0

$:.push File.expand_path("../lib", File.dirname(__FILE__))

require "optparse"
require "miga"

# OptParse flags that determine the object to load
def opt_object(opt, o, what=[:project, :dataset])
  opt.separator ""
  opt.on("-P", "--project PATH", "(Mandatory) Path to the project."
    ){ |v| o[:project]=v } if what.include? :project
  opt.on("-D", "--dataset PATH", "(Mandatory) Name of the dataset."
    ){ |v| o[:dataset]=v } if what.include? :dataset
  opt.on("-D", "--dataset PATH", "Name of the dataset."
    ){ |v| o[:dataset]=v } if what.include? :dataset_opt
  opt.on("-t", "--type STRING",
    "Type of dataset. Recognized types include:", 
    *MiGA::Project.KNOWN_TYPES.map{ |k,v| "~ #{k}: #{v[:description]}"}
    ){ |v| o[:type]=v.to_sym } if what.include? :dataset_type
end

# OptParse flags common to all actions.
def opt_common(opt, o)
  opt.on("-v", "--verbose",
    "Print additional information to STDERR."){ o[:q]=false }
  opt.on("-d", "--debug INT", "Print debugging information to STDERR.") do |v|
    v.to_i>1 ? MiGA::MiGA.DEBUG_TRACE_ON : MiGA::MiGA.DEBUG_ON
  end
  opt.on("-h", "--help", "Display this screen.") do
    puts opt
    exit
  end
  opt.separator ""
end

# OptParse flags to filter lists of datasets.
def opt_filter_datasets(opt, o, what=[:ref, :multi, :taxonomy])
  opt.on("--[no-]ref",
    "If set, uses only reference (or only non-reference) datasets."
    ){ |v| o[:ref]=v } if what.include? :ref
  opt.on("--[no-]multi",
    "If set, uses only multi-species (or only single-species) datasets."
    ){ |v| o[:multi]=v } if what.include? :multi
  opt.on("-t", "--taxonomy RANK:TAXON", "Filter by taxonomy."
    ){ |v| o[:taxonomy]=MiGA::Taxonomy.new v } if what.include? :taxonomy
end

# Filters datasets by keys set in +opt_filter_datasets+.
def filter_datasets!(ds, o)
  ds.select!{|d| d.is_ref? == o[:ref] } unless o[:ref].nil?
  ds.select! do |d|
    o[:multi] ? d.is_multi? : d.is_nonmulti?
  end unless o[:multi].nil?
  ds.select! do |d|
    (not d.metadata[:tax].nil?) and d.metadata[:tax].is_in?(o[:taxonomy])
  end unless o[:taxonomy].nil?
  ds
end

##=> Main <=

execs = Dir[File.expand_path("../actions/*.rb",
  File.dirname(__FILE__))].map{ |b| File.basename(b, ".rb") }

if %w{-v --version}.include? ARGV[0]
  puts MiGA::MiGA.VERSION
elsif %w{-V --long-version}.include? ARGV[0]
  puts MiGA::MiGA.LONG_VERSION
elsif %w{-C --citation}.include? ARGV[0]
  puts MiGA::MiGA.CITATION
elsif execs.include? ARGV[0]
  task = ARGV.shift
  ARGV << "-h" if ARGV.empty? and not %w[date].include? task
  begin
    load File.expand_path("../actions/#{task}.rb", File.dirname(__FILE__))
  rescue => err
    $stderr.puts "Exception: #{err}\n\n"
    err.backtrace.each { |l| $stderr.puts l + "\n" }
    err
  end
else
  print <<HELP.gsub(/^  /,"")
  Microbial Genomes Atlas.

  Usage: #{$0} {action} [options]

  actions:#{ execs.map{ |e| "\n       #{e}"}.join }

  generic options:
      -h, --help          Display this screen.
      -v, --version       Show MiGA version.
      -V, --long-version  Show complete MiGA version.
      -C, --citation      How to cite MiGA.
HELP
end

